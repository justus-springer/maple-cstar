# This work in progress file aims to be an introduction to the basic 
# functionality of the complexity-one package. More information is available
# in the documantation in the source code.

restart:
with(convex):
with(ComplexityOnePackage):

# We will define a two-dimensional complexity-one variety, i.e. a C*-surface.
# It all starts with the generator matrix.  # The columns of this matrix are 
# the primitive generators of the toric ambient variety of our surface.

M := <-1, -5, 2, 0; -1, -5, 0, 2; 0, -6, 1, 1>:

# We turn this plain matrix into our internal representation, namely an object
# of type `PMatrix`.

# There are multiple constructors of `PMatrix`. Check the file "PMatrix.mm" for an
# explanation of all possible constructors. The one we use here takes as 
# its first parameter the dimension of the acting torus (=1 for surfaces) and
# the plain matrix as its second parameter.

P := PMatrix(1, M):

# PMatrices contain some metadata accessible via maples member access notation `:-`
# For instance, the dimension of the corresponding variety, dimension of the acting
# torus and rank of the class group can be obtained like this:

P:-dim, P:-s, P:-classGroupRank;

# It also contains a member `case`

P:-case;

# The output "EE" means that this surface has two elliptic fixed points.

# We now define the actual C*-surface, i.e. an object of type `ComplexityOneVariety`.
# The difference between a `PMatrix` and a `ComplexityOneVariety` is that the
# latter contains two extra pieces of data: The fan of the ambient toric variety 
# and a 2x(r+1) matrix with complex entries (called the coefficient matrix) that
# determines the coefficients in the relations of the Cox Ring.

# For C*-surfaces, there is a canonical construction of the fan ambient toric
# which gets used by default, hence we don't need to specify it here. For a list
# of all possible constructors of `ComplexityOneVariety`, refer to the documentation
# in the source code.

A := <1, 0, -1; 0, 1, -1>;
X := ComplexityOneVariety(P, A);

# The ambient fan and the relations in the Cox Ring are now accessible via 
# maple's member notaton `:-`

X:-Sigma;
X:-relations;

# Note that throughout this package, we encode cones by sets of integers referring
# to the indices of their generating rays. So for instance, by `{1, 3, 4}` we mean
# the cone generated by the first, third and fourth column of the P-Matrix.

# Most of the time, one does not actually care about the coefficients in the
# relations of the Cox Ring and instead works with families of complexity one
# varieties that are parameterized by their coefficient matrices. That is why 
# the coefficient matrix `A` is an optional parameter and we could also write

Xfam := ComplexityOneVariety(P);

# We have to keep in mind though, that `Xfam` now denotes a whole family of
# complexity-one varieties instead of just a single one and some member variables
# like `relations` will be undefined for `Xfam`.

# We can now start to compute invariants of the C*-surface.
# First, the divisor class group. Note that this takes a `PMatrix` instead of
# a `ComplexityOneVariety`, since it does not actually depend on the fan structure.

getClassGroup(P); # output: [1, 4]

# Here, the output is a list of integers where the first entry is the rank and the
# remaining entries are the elementary divisors of the associated finitely generated
# abelian group. Hence this output means that the class group is isomorphic to 
# Z + Z/4Z.

# Here are a few other invariants that only depend on the PMatrix:

getCanonicalDivisorClass(P); # output: [-2, 0]

isLogTerminal(P); # output: true

getSingularityType(P); # output: "eAeD" (see arXiv:2207.14790 for this notation)

# Check out the file `PMatrix.mm` for more. 

# We turn to invariants depending on the fan structure of the ambient toric variety,
# i.e. that take an object of type `ComplexityOneVariety` as input. First, some
# checks on being Q-Factorial, Q-Gorenstein, Gorenstein and Fano:

isQfactorial(X); # output: true

isQgorenstein(X); # output: true

isGorenstein(X); # output: false

isFano(X); # output: true

# Next, computing the Gorenstein Index and the Picard Index:

getGorensteinIndex(X); # output: 3

getPicardIndex(X); # output: 24

# Next, we compute intersection numbers. Note that there are four torus-invariant
# prime divisors on `X`, one for each ray of the fan. The intersection matrix 
# the intersection numbers of all possible combinations of the torus-invariant prime
# divisors with each other.

getIntersectionMatrix(X);

# A popular invariant is the self-intersection number of the anticanonical divisor:

getAnticanonicalSelfIntersection(X); # output: 2/3

# We also compute a minimal resolution of singularities. The result will be another
# object of type `ComplexityOneVariety`:

Xres := minimalResolution(X);

# `Xres` is factorial (indeed, it is smooth)

isFactorial(Xres); # output: true

# We can also view its generator matrix:

Xres:-P:-mat;




